"""
Servidor Web para o Sistema Financeiro
"""
from flask import Flask, render_template, request, jsonify, send_file, send_from_directory
from flask_cors import CORS
from database import DatabaseManager
from database import pagar_lancamento as db_pagar_lancamento
from database import cancelar_lancamento as db_cancelar_lancamento
from database import obter_lancamento as db_obter_lancamento
from database import atualizar_cliente, atualizar_fornecedor
from models import ContaBancaria, Lancamento, Categoria, TipoLancamento, StatusLancamento
from decimal import Decimal
from datetime import datetime, date, timedelta
import json
import os

app = Flask(__name__, static_folder='static', template_folder='templates')
CORS(app, resources={r"/api/*": {"origins": "*", "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS"]}})

# Inicializar banco de dados
db = DatabaseManager()

# Migrar dados JSON se existir
if os.path.exists('dados_financeiros.json'):
    print("Migrando dados do JSON para SQLite...")
    db.migrar_dados_json('dados_financeiros.json')
    print("Migração concluída!")


# === ROTAS DE CONTAS BANCÁRIAS ===

@app.route('/api/contas', methods=['GET'])
def listar_contas():
    """Lista todas as contas bancárias com saldo real"""
    contas = db.listar_contas()
    lancamentos = db.listar_lancamentos()
    
    # Calcular saldo real de cada conta
    contas_com_saldo = []
    for c in contas:
        saldo_real = Decimal(str(c.saldo_inicial))
        
        # Somar/subtrair lançamentos pagos desta conta
        for lanc in lancamentos:
            if lanc.status == StatusLancamento.PAGO and hasattr(lanc, 'conta_bancaria') and lanc.conta_bancaria == c.nome:
                valor_decimal = Decimal(str(lanc.valor))
                if lanc.tipo == TipoLancamento.RECEITA:
                    saldo_real += valor_decimal
                else:
                    saldo_real -= valor_decimal
        
        contas_com_saldo.append({
            'nome': c.nome,
            'banco': c.banco,
            'agencia': c.agencia,
            'conta': c.conta,
            'saldo_inicial': float(c.saldo_inicial),
            'saldo': float(saldo_real)  # Saldo real com movimentações
        })
    
    return jsonify(contas_com_saldo)


@app.route('/api/contas', methods=['POST'])
def adicionar_conta():
    """Adiciona uma nova conta bancária"""
    try:
        data = request.json
        print(f"\n=== Recebendo nova conta ===")
        print(f"Dados recebidos: {data}")
        
        conta = ContaBancaria(
            nome=data['nome'],  # type: ignore
            banco=data['banco'],  # type: ignore
            agencia=data['agencia'],  # type: ignore
            conta=data['conta'],  # type: ignore
            saldo_inicial=float(data.get('saldo_inicial', 0) if data else 0)  # type: ignore
        )
        conta_id = db.adicionar_conta(conta)
        print(f"Conta adicionada com sucesso! ID: {conta_id}")
        return jsonify({'success': True, 'id': conta_id})
    except Exception as e:
        print(f"ERRO ao adicionar conta: {str(e)}")
        import traceback
        traceback.print_exc()
        error_msg = str(e)
        if 'UNIQUE constraint' in error_msg:
            error_msg = 'Já existe uma conta com este nome'
        return jsonify({'success': False, 'error': error_msg}), 400


@app.route('/api/contas/<path:nome>', methods=['GET', 'PUT', 'DELETE', 'OPTIONS'])  # type: ignore
def modificar_conta(nome):
    """Atualiza ou remove uma conta bancária"""
    print(f"\n=== ROTA CHAMADA: modificar_conta ===")
    print(f"Método HTTP: {request.method}")
    print(f"Nome recebido: {nome}")
    
    # Responder ao preflight OPTIONS
    if request.method == 'OPTIONS':
        return jsonify({'success': True}), 200
    
    if request.method == 'PUT':
        try:
            data = request.json
            print(f"\n=== Atualizando conta ===")
            print(f"Nome original: {nome}")
            print(f"Dados recebidos: {data}")
            
            conta = ContaBancaria(
                nome=data['nome'],  # type: ignore
                banco=data['banco'],  # type: ignore
                agencia=data['agencia'],  # type: ignore
                conta=data['conta'],  # type: ignore
                saldo_inicial=float(data.get('saldo_inicial', 0) if data else 0)  # type: ignore
            )
            success = db.atualizar_conta(nome, conta)
            print(f"Conta atualizada com sucesso!")
            return jsonify({'success': success})
        except Exception as e:
            print(f"ERRO ao atualizar conta: {str(e)}")
            import traceback
            traceback.print_exc()
            error_msg = str(e)
            if 'UNIQUE constraint' in error_msg:
                error_msg = 'Já existe uma conta com este nome'
            return jsonify({'success': False, 'error': error_msg}), 400
    
    elif request.method == 'DELETE':
        try:
            success = db.excluir_conta(nome)
            return jsonify({'success': success})
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 400


# === ROTAS DE CATEGORIAS ===

@app.route('/api/categorias', methods=['GET'])
def listar_categorias():
    """Lista todas as categorias"""
    categorias = db.listar_categorias()
    return jsonify([{
        'nome': c.nome,
        'tipo': c.tipo.value,
        'subcategorias': c.subcategorias
    } for c in categorias])


@app.route('/api/categorias', methods=['POST'])
def adicionar_categoria():
    """Adiciona uma nova categoria"""
    try:
        data = request.json
        print(f"\n=== Recebendo nova categoria ===")
        print(f"Dados recebidos: {data}")
        
        # Converter tipo para minúscula para compatibilidade com o enum
        tipo_str = data['tipo'].lower() if data and data.get('tipo') else 'receita'  # type: ignore
        
        categoria = Categoria(
            nome=data['nome'],  # type: ignore
            tipo=TipoLancamento(tipo_str),  # type: ignore
            subcategorias=data.get('subcategorias', []) if data else []  # type: ignore
        )
        categoria_id = db.adicionar_categoria(categoria)
        print(f"Categoria adicionada com sucesso! ID: {categoria_id}")
        return jsonify({'success': True, 'id': categoria_id})
    except Exception as e:
        print(f"ERRO ao adicionar categoria: {str(e)}")
        import traceback
        traceback.print_exc()
        error_msg = str(e)
        if 'UNIQUE constraint' in error_msg:
            error_msg = 'Já existe uma categoria com este nome'
        return jsonify({'success': False, 'error': error_msg}), 400


@app.route('/api/categorias/<path:nome>', methods=['PUT', 'DELETE'])  # type: ignore
def modificar_categoria(nome):
    """Atualiza ou remove uma categoria"""
    if request.method == 'PUT':
        try:
            data = request.json
            print(f"\n=== Atualizando categoria ===")
            print(f"Nome original: {nome}")
            print(f"Dados recebidos: {data}")
            
            # Converter tipo para minúscula para compatibilidade com o enum
            tipo_str = data['tipo'].lower() if data and data.get('tipo') else 'receita'  # type: ignore
            
            categoria = Categoria(
                nome=data['nome'],  # type: ignore
                tipo=TipoLancamento(tipo_str),  # type: ignore
                subcategorias=data.get('subcategorias', []) if data else []  # type: ignore
            )
            success = db.atualizar_categoria(categoria)
            print(f"Categoria atualizada com sucesso!")
            return jsonify({'success': success})
        except Exception as e:
            print(f"ERRO ao atualizar categoria: {str(e)}")
            import traceback
            traceback.print_exc()
            error_msg = str(e)
            if 'UNIQUE constraint' in error_msg:
                error_msg = 'Já existe uma categoria com este nome'
            return jsonify({'success': False, 'error': error_msg}), 400
    
    elif request.method == 'DELETE':
        try:
            success = db.excluir_categoria(nome)
            return jsonify({'success': success})
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 400


# === ROTAS DE CLIENTES ===

@app.route('/api/clientes', methods=['GET'])
def listar_clientes():
    """Lista todos os clientes"""
    clientes = db.listar_clientes()
    return jsonify(clientes)


@app.route('/api/clientes', methods=['POST'])
def adicionar_cliente():
    """Adiciona um novo cliente"""
    try:
        data = request.json
        print(f"\n=== Recebendo novo cliente ===")
        print(f"Dados recebidos: {data}")
        
        cliente_id = db.adicionar_cliente(data)  # type: ignore
        print(f"Cliente adicionado com sucesso! ID: {cliente_id}")
        return jsonify({'success': True, 'id': cliente_id})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/clientes/<path:nome>', methods=['PUT', 'DELETE'])  # type: ignore
def modificar_cliente(nome):
    """Atualiza ou remove um cliente"""
    if request.method == 'PUT':
        try:
            data = request.json
            print(f"\n=== Atualizando cliente ===")
            print(f"URL recebida: {request.url}")
            print(f"Nome da URL (raw): '{nome}'")
            print(f"Nome da URL (tipo): {type(nome)}")
            print(f"Dados recebidos: {data}")
            if data:
                print(f"Novo nome nos dados: '{data.get('nome')}'")
                print(f"Nova razão social nos dados: '{data.get('razao_social')}'")
            
            success = atualizar_cliente(nome, data)
            print(f"Cliente atualizado: {success}")
            return jsonify({'success': success})
        except Exception as e:
            print(f"ERRO ao atualizar cliente: {str(e)}")
            import traceback
            traceback.print_exc()
            error_msg = str(e)
            if 'UNIQUE constraint' in error_msg:
                error_msg = 'Já existe um cliente com este nome'
            return jsonify({'success': False, 'error': error_msg}), 400
    
    elif request.method == 'DELETE':
        try:
            success = db.excluir_cliente(nome)
            return jsonify({'success': success})
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 400


# === ROTAS DE FORNECEDORES ===

@app.route('/api/fornecedores', methods=['GET'])
def listar_fornecedores():
    """Lista todos os fornecedores"""
    fornecedores = db.listar_fornecedores()
    return jsonify(fornecedores)


@app.route('/api/fornecedores', methods=['POST'])
def adicionar_fornecedor():
    """Adiciona um novo fornecedor"""
    try:
        data = request.json
        print(f"\n=== Recebendo novo fornecedor ===")
        print(f"Dados recebidos: {data}")
        
        fornecedor_id = db.adicionar_fornecedor(data)  # type: ignore
        print(f"Fornecedor adicionado com sucesso! ID: {fornecedor_id}")
        return jsonify({'success': True, 'id': fornecedor_id})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/fornecedores/<path:nome>', methods=['PUT', 'DELETE'])  # type: ignore
def modificar_fornecedor(nome):
    """Atualiza ou remove um fornecedor"""
    if request.method == 'PUT':
        try:
            data = request.json
            print(f"\n=== Atualizando fornecedor ===")
            print(f"Nome original: {nome}")
            print(f"Dados recebidos: {data}")
            
            success = atualizar_fornecedor(nome, data)
            print(f"Fornecedor atualizado com sucesso!")
            return jsonify({'success': success})
        except Exception as e:
            print(f"ERRO ao atualizar fornecedor: {str(e)}")
            import traceback
            traceback.print_exc()
            error_msg = str(e)
            if 'UNIQUE constraint' in error_msg:
                error_msg = 'Já existe um fornecedor com este nome'
            return jsonify({'success': False, 'error': error_msg}), 400
    
    elif request.method == 'DELETE':
        try:
            success = db.excluir_fornecedor(nome)
            return jsonify({'success': success})
        except Exception as e:
            return jsonify({'success': False, 'error': str(e)}), 400


# === ROTAS DE LANÇAMENTOS ===

@app.route('/api/lancamentos', methods=['GET'])
def listar_lancamentos():
    """Lista todos os lançamentos"""
    tipo_filtro = request.args.get('tipo')
    lancamentos = db.listar_lancamentos()
    
    # Filtrar por tipo se especificado (case-insensitive)
    if tipo_filtro:
        lancamentos = [l for l in lancamentos if l.tipo.value.upper() == tipo_filtro.upper()]
    
    return jsonify([{
        'id': l.id if hasattr(l, 'id') else None,
        'tipo': l.tipo.value,
        'descricao': l.descricao,
        'valor': float(l.valor),
        'data_vencimento': l.data_vencimento.isoformat() if l.data_vencimento else None,
        'data_pagamento': l.data_pagamento.isoformat() if l.data_pagamento else None,
        'status': l.status.value,
        'categoria': l.categoria,
        'subcategoria': l.subcategoria,
        'conta_bancaria': l.conta_bancaria,
        'pessoa': l.pessoa,
        'observacoes': l.observacoes,
        'num_documento': getattr(l, 'num_documento', ''),
        'recorrente': getattr(l, 'recorrente', False),
        'frequencia_recorrencia': getattr(l, 'frequencia_recorrencia', '')
    } for l in lancamentos])


@app.route('/api/lancamentos', methods=['POST'])
def adicionar_lancamento():
    """Adiciona um novo lançamento (com suporte a parcelamento)"""
    try:
        data = request.json
        print(f"\n=== Recebendo novo lançamento ===")
        print(f"Dados recebidos: {data}")
        
        parcelas = int(data.get('parcelas', 1)) if data else 1
        
        if parcelas > 1:
            # Criar múltiplos lançamentos para parcelas
            from dateutil.relativedelta import relativedelta
            data_base = datetime.fromisoformat(data['data_vencimento']) if data and data.get('data_vencimento') else datetime.now()
            valor_parcela = float(data['valor']) / parcelas if data else 0.0
            tipo_str = data['tipo'].lower() if data and data.get('tipo') else 'receita'
            
            lancamentos_ids = []
            for i in range(parcelas):
                data_venc = data_base + relativedelta(months=i)
                descricao_parcela = f"{data['descricao']} ({i+1}/{parcelas})" if data else f"Parcela {i+1}/{parcelas}"
                
                lancamento = Lancamento(
                    descricao=descricao_parcela,
                    valor=valor_parcela,
                    tipo=TipoLancamento(tipo_str),
                    categoria=data.get('categoria', '') if data else '',
                    data_vencimento=data_venc,
                    data_pagamento=None,
                    conta_bancaria=data['conta_bancaria'] if data else '',
                    pessoa=data.get('pessoa', '') if data else '',
                    observacoes=data.get('observacoes', '') if data else '',
                    num_documento=data.get('num_documento', '') if data else '',
                    subcategoria=data.get('subcategoria', '') if data else ''
                )
                
                if data and data.get('status'):
                    lancamento.status = StatusLancamento(data['status'])
                
                lancamento_id = db.adicionar_lancamento(lancamento)
                lancamentos_ids.append(lancamento_id)
            
            print(f"Lançamentos parcelados adicionados! IDs: {lancamentos_ids}")
            return jsonify({'success': True, 'ids': lancamentos_ids})
        else:
            # Lançamento único (sem parcelamento)
            data_venc = datetime.fromisoformat(data['data_vencimento']) if data and data.get('data_vencimento') else datetime.now()
            data_pag = datetime.fromisoformat(data['data_pagamento']) if data and data.get('data_pagamento') else None
            tipo_str = data['tipo'].lower() if data and data.get('tipo') else 'receita'
            
            lancamento = Lancamento(
                descricao=data['descricao'] if data else '',
                valor=float(data['valor']) if data else 0.0,
                tipo=TipoLancamento(tipo_str),
                categoria=data.get('categoria', '') if data else '',
                data_vencimento=data_venc,
                data_pagamento=data_pag,
                conta_bancaria=data['conta_bancaria'] if data else '',
                pessoa=data.get('pessoa', '') if data else '',
                observacoes=data.get('observacoes', '') if data else '',
                num_documento=data.get('num_documento', '') if data else '',
                subcategoria=data.get('subcategoria', '') if data else ''
            )
            
            if data and data.get('status'):
                lancamento.status = StatusLancamento(data['status'])
            
            lancamento_id = db.adicionar_lancamento(lancamento)
            print(f"Lançamento adicionado com sucesso! ID: {lancamento_id}")
            return jsonify({'success': True, 'id': lancamento_id})
    except Exception as e:
        print(f"ERRO ao adicionar lançamento: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/lancamentos/<int:lancamento_id>', methods=['GET'])
def obter_lancamento_route(lancamento_id):
    """Retorna os dados de um lançamento específico"""
    try:
        lancamento = db_obter_lancamento(lancamento_id)
        if lancamento:
            return jsonify(lancamento), 200
        else:
            return jsonify({'error': 'Lançamento não encontrado'}), 404
    except Exception as e:
        print(f"ERRO ao obter lançamento: {str(e)}")
        return jsonify({'error': str(e)}), 500


@app.route('/api/lancamentos/<int:lancamento_id>', methods=['DELETE', 'OPTIONS'])
def excluir_lancamento(lancamento_id):
    """Remove um lançamento"""
    if request.method == 'OPTIONS':
        return jsonify({'success': True}), 200
    
    try:
        print(f"\n=== Excluindo lançamento ID: {lancamento_id} ===")
        success = db.excluir_lancamento(lancamento_id)
        print(f"Resultado da exclusão: {success}")
        
        if not success:
            print("AVISO: Nenhum registro foi excluído (ID não encontrado?)")
            return jsonify({'success': False, 'error': 'Lançamento não encontrado'}), 404
        
        print("Lançamento excluído com sucesso!")
        return jsonify({'success': True})
    except Exception as e:
        print(f"ERRO ao excluir lançamento: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'error': str(e)}), 400


# === ROTAS DE RELATÓRIOS ===

@app.route('/api/relatorios/fluxo-caixa', methods=['GET'])
def relatorio_fluxo_caixa():
    """Relatório de fluxo de caixa"""
    data_inicio_str = request.args.get('data_inicio', (date.today() - timedelta(days=30)).isoformat())
    data_fim_str = request.args.get('data_fim', date.today().isoformat())
    
    # Converter strings para date objects
    if isinstance(data_inicio_str, str):
        data_inicio = datetime.strptime(data_inicio_str, '%Y-%m-%d').date()
    else:
        data_inicio = data_inicio_str
        
    if isinstance(data_fim_str, str):
        data_fim = datetime.strptime(data_fim_str, '%Y-%m-%d').date()
    else:
        data_fim = data_fim_str
    
    lancamentos = db.listar_lancamentos()
    lancamentos_periodo = []
    for l in lancamentos:
        if l.status == StatusLancamento.PAGO and l.data_pagamento:
            # Garantir que ambos sejam date, não datetime
            data_pgto = l.data_pagamento if isinstance(l.data_pagamento, date) and not isinstance(l.data_pagamento, datetime) else (l.data_pagamento.date() if isinstance(l.data_pagamento, datetime) else l.data_pagamento)
            if isinstance(data_pgto, date) and isinstance(data_inicio, date) and isinstance(data_fim, date):
                if data_inicio <= data_pgto <= data_fim:
                    lancamentos_periodo.append(l)
    
    resultado = []
    for l in lancamentos_periodo:
        data_pgto = l.data_pagamento
        if hasattr(data_pgto, 'date'):
            data_pgto = data_pgto.date()
        resultado.append({
            'tipo': l.tipo.value,
            'descricao': l.descricao,
            'valor': float(l.valor),
            'data_pagamento': data_pgto.isoformat() if data_pgto else None,
            'categoria': l.categoria,
            'subcategoria': l.subcategoria,
            'pessoa': l.pessoa,
            'conta_bancaria': l.conta_bancaria if hasattr(l, 'conta_bancaria') else None
        })
    return jsonify(resultado)


@app.route('/api/relatorios/dashboard', methods=['GET'])
def dashboard():
    """Dados para o dashboard"""
    try:
        lancamentos = db.listar_lancamentos()
        contas = db.listar_contas()
        
        # Calcular saldos
        saldo_total = Decimal('0')
        for c in contas:
            saldo_total += Decimal(str(c.saldo_inicial))
        
        for lanc in lancamentos:
            if lanc.status == StatusLancamento.PAGO:
                valor_decimal = Decimal(str(lanc.valor))
                if lanc.tipo == TipoLancamento.RECEITA:
                    saldo_total += valor_decimal
                else:
                    saldo_total -= valor_decimal
        
        # Contas pendentes
        hoje = date.today()
        contas_receber = Decimal('0')
        contas_pagar = Decimal('0')
        contas_vencidas = Decimal('0')
        
        for l in lancamentos:
            valor_decimal = Decimal(str(l.valor))
            if l.tipo == TipoLancamento.RECEITA and l.status == StatusLancamento.PENDENTE:
                contas_receber += valor_decimal
            if l.tipo == TipoLancamento.DESPESA and l.status == StatusLancamento.PENDENTE:
                contas_pagar += valor_decimal
            # Converter datetime para date se necessário
            data_venc = l.data_vencimento.date() if hasattr(l.data_vencimento, 'date') else l.data_vencimento
            if l.status == StatusLancamento.PENDENTE and data_venc < hoje:
                contas_vencidas += valor_decimal
        
        return jsonify({
            'saldo_total': float(saldo_total),
            'contas_receber': float(contas_receber),
            'contas_pagar': float(contas_pagar),
            'contas_vencidas': float(contas_vencidas),
            'total_contas': len(contas),
            'total_lancamentos': len(lancamentos)
        })
    except Exception as e:
        print(f"Erro no dashboard: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


@app.route('/api/relatorios/fluxo-projetado', methods=['GET'])
def relatorio_fluxo_projetado():
    """Relatório de fluxo de caixa PROJETADO (incluindo lançamentos pendentes futuros)"""
    try:
        # Receber filtros - padrão é projetar próximos X dias
        dias = request.args.get('dias')
        dias = int(dias) if dias else 30
        
        hoje = date.today()
        data_inicial = hoje
        data_final = hoje + timedelta(days=dias)
        periodo_texto = f"PROJEÇÃO - PRÓXIMOS {dias} DIAS"
        
        lancamentos = db.listar_lancamentos()
        contas = db.listar_contas()
        
        # Saldo atual (saldo inicial + todos os lançamentos pagos até hoje)
        saldo_atual = Decimal('0')
        for c in contas:
            saldo_atual += Decimal(str(c.saldo_inicial))
        
        # Adicionar todas as receitas e despesas JÁ PAGAS até hoje
        for l in lancamentos:
            if l.status == StatusLancamento.PAGO and l.data_pagamento and l.data_pagamento <= hoje:
                valor_decimal = Decimal(str(l.valor))
                if l.tipo == TipoLancamento.RECEITA:
                    saldo_atual += valor_decimal
                else:
                    saldo_atual -= valor_decimal
        
        # Buscar lançamentos PENDENTES para projeção futura
        lancamentos_futuros = []
        receitas_previstas = Decimal('0')
        despesas_previstas = Decimal('0')
        
        for l in lancamentos:
            if l.status == StatusLancamento.PENDENTE and data_inicial <= l.data_vencimento <= data_final:
                lancamentos_futuros.append(l)
                valor_decimal = Decimal(str(l.valor))
                if l.tipo == TipoLancamento.RECEITA:
                    receitas_previstas += valor_decimal
                else:
                    despesas_previstas += valor_decimal
        
        # Calcular saldo projetado
        saldo_projetado = saldo_atual + receitas_previstas - despesas_previstas
        
        # Ordenar por data de vencimento
        lancamentos_futuros.sort(key=lambda x: x.data_vencimento)
        
        # Montar fluxo projetado dia a dia
        fluxo = []
        saldo_acumulado = saldo_atual
        
        for lanc in lancamentos_futuros:
            valor_decimal = Decimal(str(lanc.valor))
            if lanc.tipo == TipoLancamento.RECEITA:
                saldo_acumulado += valor_decimal
            else:
                saldo_acumulado -= valor_decimal
            
            fluxo.append({
                'data_vencimento': lanc.data_vencimento.isoformat(),
                'descricao': lanc.descricao,
                'tipo': lanc.tipo.value,
                'valor': float(lanc.valor),
                'categoria': lanc.categoria,
                'subcategoria': lanc.subcategoria,
                'pessoa': lanc.pessoa,
                'conta_bancaria': lanc.conta_bancaria,
                'saldo_acumulado': float(saldo_acumulado),
                'status': 'PENDENTE'
            })
        
        return jsonify({
            'periodo_texto': periodo_texto,
            'data_inicial': data_inicial.isoformat(),
            'data_final': data_final.isoformat(),
            'saldo_atual': float(saldo_atual),
            'receitas_previstas': float(receitas_previstas),
            'despesas_previstas': float(despesas_previstas),
            'saldo_projetado': float(saldo_projetado),
            'fluxo': fluxo
        })
    except Exception as e:
        print(f"Erro no fluxo projetado: {str(e)}")
        import traceback
        traceback.print_exc()
        return jsonify({'error': str(e)}), 500


@app.route('/api/relatorios/analise-contas', methods=['GET'])
def relatorio_analise_contas():
    """Relatório de análise de contas a pagar e receber"""
    lancamentos = db.listar_lancamentos()
    hoje = date.today()
    
    # Função auxiliar para converter datetime para date
    def get_date(data):
        return data.date() if hasattr(data, 'date') else data
    
    # Totais
    total_receber = sum(l.valor for l in lancamentos 
                       if l.tipo == TipoLancamento.RECEITA and l.status == StatusLancamento.PENDENTE)
    total_pagar = sum(l.valor for l in lancamentos 
                     if l.tipo == TipoLancamento.DESPESA and l.status == StatusLancamento.PENDENTE)
    
    receber_vencidos = sum(l.valor for l in lancamentos 
                          if l.tipo == TipoLancamento.RECEITA and 
                          l.status == StatusLancamento.PENDENTE and 
                          get_date(l.data_vencimento) < hoje)
    pagar_vencidos = sum(l.valor for l in lancamentos 
                        if l.tipo == TipoLancamento.DESPESA and 
                        l.status == StatusLancamento.PENDENTE and 
                        get_date(l.data_vencimento) < hoje)
    
    # Aging (análise de vencimento)
    pendentes = [l for l in lancamentos if l.status == StatusLancamento.PENDENTE]
    
    vencidos = sum(l.valor for l in pendentes if (get_date(l.data_vencimento) - hoje).days < 0)  # type: ignore
    ate_7 = sum(l.valor for l in pendentes if 0 <= (get_date(l.data_vencimento) - hoje).days <= 7)  # type: ignore
    ate_15 = sum(l.valor for l in pendentes if 7 < (get_date(l.data_vencimento) - hoje).days <= 15)  # type: ignore
    ate_30 = sum(l.valor for l in pendentes if 15 < (get_date(l.data_vencimento) - hoje).days <= 30)  # type: ignore
    ate_60 = sum(l.valor for l in pendentes if 30 < (get_date(l.data_vencimento) - hoje).days <= 60)  # type: ignore
    ate_90 = sum(l.valor for l in pendentes if 60 < (get_date(l.data_vencimento) - hoje).days <= 90)  # type: ignore
    acima_90 = sum(l.valor for l in pendentes if (get_date(l.data_vencimento) - hoje).days > 90)  # type: ignore
    
    return jsonify({
        'total_receber': float(total_receber),
        'total_pagar': float(total_pagar),
        'receber_vencidos': float(receber_vencidos),
        'pagar_vencidos': float(pagar_vencidos),
        'aging': {
            'vencidos': float(vencidos),
            'ate_7': float(ate_7),
            'ate_15': float(ate_15),
            'ate_30': float(ate_30),
            'ate_60': float(ate_60),
            'ate_90': float(ate_90),
            'acima_90': float(acima_90)
        }
    })


@app.route('/api/lancamentos/<int:lancamento_id>/pagar', methods=['PUT'])
def pagar_lancamento(lancamento_id):
    """Marca um lançamento como pago"""
    try:
        data = request.json
        conta = data.get('conta_bancaria', '') if data else ''
        data_pagamento = datetime.fromisoformat(data.get('data_pagamento', datetime.now().isoformat())) if data else datetime.now()
        juros = float(data.get('juros', 0)) if data else 0
        
        success = db_pagar_lancamento(lancamento_id, conta, data_pagamento, juros)
        return jsonify({'success': success})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/lancamentos/<int:lancamento_id>/liquidar', methods=['POST'])
def liquidar_lancamento(lancamento_id):
    """Liquida um lançamento (marca como pago com dados completos)"""
    try:
        data = request.json or {}
        conta = data.get('conta_bancaria', '')
        data_pagamento_str = data.get('data_pagamento', '')
        juros = float(data.get('juros', 0))
        
        if not conta:
            return jsonify({'success': False, 'error': 'Conta bancária é obrigatória'}), 400
        
        if not data_pagamento_str:
            return jsonify({'success': False, 'error': 'Data de pagamento é obrigatória'}), 400
        
        data_pagamento = datetime.fromisoformat(data_pagamento_str)
        
        success = db_pagar_lancamento(lancamento_id, conta, data_pagamento, juros)
        return jsonify({'success': success})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


@app.route('/api/lancamentos/<int:lancamento_id>/cancelar', methods=['PUT'])
def cancelar_lancamento_route(lancamento_id):
    """Cancela um lançamento"""
    try:
        success = db_cancelar_lancamento(lancamento_id)
        return jsonify({'success': success})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 400


# === ROTA PRINCIPAL ===

@app.route('/')
def index():
    """Página principal - Nova interface moderna"""
    return render_template('interface_nova.html')

@app.route('/old')
def old_index():
    """Página antiga (backup)"""
    return render_template('interface.html')

@app.route('/legacy')
def legacy_index():
    """Página legado"""
    return render_template('index.html')

@app.route('/teste')
def teste():
    """Página de teste JavaScript"""
    return render_template('teste.html')

@app.route('/teste-api')
def teste_api():
    """Página de teste API"""
    return render_template('teste_api.html')

# === ENDPOINTS DE RELATÓRIOS ===

@app.route('/api/relatorios/resumo-parceiros', methods=['GET'])
def relatorio_resumo_parceiros():
    """Relatório de resumo por cliente/fornecedor"""
    try:
        data_inicio = request.args.get('data_inicio', (date.today() - timedelta(days=30)).isoformat())
        data_fim = request.args.get('data_fim', date.today().isoformat())
        
        data_inicio = datetime.fromisoformat(data_inicio).date()
        data_fim = datetime.fromisoformat(data_fim).date()
        
        lancamentos = db.listar_lancamentos()
        
        # Agrupar por pessoa
        resumo_clientes = {}
        resumo_fornecedores = {}
        
        for l in lancamentos:
            if l.status == StatusLancamento.PAGO and l.data_pagamento:
                data_pag = l.data_pagamento.date() if hasattr(l.data_pagamento, 'date') else l.data_pagamento
                if data_inicio <= data_pag <= data_fim and l.pessoa:
                    valor = float(l.valor)
                    
                    if l.tipo == TipoLancamento.RECEITA:
                        if l.pessoa not in resumo_clientes:
                            resumo_clientes[l.pessoa] = {'total': 0, 'quantidade': 0}
                        resumo_clientes[l.pessoa]['total'] += valor
                        resumo_clientes[l.pessoa]['quantidade'] += 1
                    else:
                        if l.pessoa not in resumo_fornecedores:
                            resumo_fornecedores[l.pessoa] = {'total': 0, 'quantidade': 0}
                        resumo_fornecedores[l.pessoa]['total'] += valor
                        resumo_fornecedores[l.pessoa]['quantidade'] += 1
        
        return jsonify({
            'clientes': resumo_clientes,
            'fornecedores': resumo_fornecedores,
            'periodo': {
                'inicio': data_inicio.isoformat(),
                'fim': data_fim.isoformat()
            }
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/relatorios/analise-categorias', methods=['GET'])
def relatorio_analise_categorias():
    """Relatório de análise por categorias"""
    try:
        data_inicio = request.args.get('data_inicio', (date.today() - timedelta(days=30)).isoformat())
        data_fim = request.args.get('data_fim', date.today().isoformat())
        
        data_inicio = datetime.fromisoformat(data_inicio).date()
        data_fim = datetime.fromisoformat(data_fim).date()
        
        lancamentos = db.listar_lancamentos()
        
        # Agrupar por categoria e subcategoria
        receitas = {}
        despesas = {}
        
        for l in lancamentos:
            if l.status == StatusLancamento.PAGO and l.data_pagamento:
                data_pag = l.data_pagamento.date() if hasattr(l.data_pagamento, 'date') else l.data_pagamento
                if data_inicio <= data_pag <= data_fim:
                    categoria = l.categoria or 'Sem Categoria'
                    subcategoria = l.subcategoria or 'Sem Subcategoria'
                    valor = float(l.valor)
                    
                    if l.tipo == TipoLancamento.RECEITA:
                        if categoria not in receitas:
                            receitas[categoria] = {}
                        if subcategoria not in receitas[categoria]:
                            receitas[categoria][subcategoria] = {'total': 0, 'quantidade': 0}
                        receitas[categoria][subcategoria]['total'] += valor
                        receitas[categoria][subcategoria]['quantidade'] += 1
                    else:
                        if categoria not in despesas:
                            despesas[categoria] = {}
                        if subcategoria not in despesas[categoria]:
                            despesas[categoria][subcategoria] = {'total': 0, 'quantidade': 0}
                        despesas[categoria][subcategoria]['total'] += valor
                        despesas[categoria][subcategoria]['quantidade'] += 1
        
        return jsonify({
            'receitas': receitas,
            'despesas': despesas,
            'periodo': {
                'inicio': data_inicio.isoformat(),
                'fim': data_fim.isoformat()
            }
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/relatorios/comparativo-periodos', methods=['GET'])
def relatorio_comparativo_periodos():
    """Relatório comparativo entre períodos"""
    try:
        # Período 1
        data_inicio1 = request.args.get('data_inicio1')
        data_fim1 = request.args.get('data_fim1')
        
        # Período 2
        data_inicio2 = request.args.get('data_inicio2')
        data_fim2 = request.args.get('data_fim2')
        
        if not all([data_inicio1, data_fim1, data_inicio2, data_fim2]):
            return jsonify({'error': 'Parâmetros de datas obrigatórios'}), 400
        
        data_inicio1 = datetime.fromisoformat(data_inicio1).date()
        data_fim1 = datetime.fromisoformat(data_fim1).date()
        data_inicio2 = datetime.fromisoformat(data_inicio2).date()
        data_fim2 = datetime.fromisoformat(data_fim2).date()
        
        lancamentos = db.listar_lancamentos()
        
        def calcular_periodo(data_ini, data_fim):
            receitas = Decimal('0')
            despesas = Decimal('0')
            
            for l in lancamentos:
                if l.status == StatusLancamento.PAGO and l.data_pagamento:
                    data_pag = l.data_pagamento.date() if hasattr(l.data_pagamento, 'date') else l.data_pagamento
                    if data_ini <= data_pag <= data_fim:
                        valor = Decimal(str(l.valor))
                        if l.tipo == TipoLancamento.RECEITA:
                            receitas += valor
                        else:
                            despesas += valor
            
            return {
                'receitas': float(receitas),
                'despesas': float(despesas),
                'saldo': float(receitas - despesas)
            }
        
        periodo1 = calcular_periodo(data_inicio1, data_fim1)
        periodo2 = calcular_periodo(data_inicio2, data_fim2)
        
        # Calcular variações
        variacao_receitas = ((periodo2['receitas'] - periodo1['receitas']) / periodo1['receitas'] * 100) if periodo1['receitas'] > 0 else 0
        variacao_despesas = ((periodo2['despesas'] - periodo1['despesas']) / periodo1['despesas'] * 100) if periodo1['despesas'] > 0 else 0
        variacao_saldo = ((periodo2['saldo'] - periodo1['saldo']) / abs(periodo1['saldo']) * 100) if periodo1['saldo'] != 0 else 0
        
        return jsonify({
            'periodo1': {
                'datas': {'inicio': data_inicio1.isoformat(), 'fim': data_fim1.isoformat()},
                'dados': periodo1
            },
            'periodo2': {
                'datas': {'inicio': data_inicio2.isoformat(), 'fim': data_fim2.isoformat()},
                'dados': periodo2
            },
            'variacoes': {
                'receitas': round(variacao_receitas, 2),
                'despesas': round(variacao_despesas, 2),
                'saldo': round(variacao_saldo, 2)
            }
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/relatorios/indicadores', methods=['GET'])
def relatorio_indicadores():
    """Relatório de indicadores financeiros"""
    try:
        lancamentos = db.listar_lancamentos()
        contas = db.listar_contas()
        
        hoje = date.today()
        inicio_mes = date(hoje.year, hoje.month, 1)
        
        # Totais do mês atual
        receitas_mes = Decimal('0')
        despesas_mes = Decimal('0')
        
        # Totais a receber/pagar
        total_receber = Decimal('0')
        total_pagar = Decimal('0')
        
        # Vencidos
        vencidos_receber = Decimal('0')
        vencidos_pagar = Decimal('0')
        
        for l in lancamentos:
            if l.status == StatusLancamento.PAGO and l.data_pagamento:
                data_pag = l.data_pagamento.date() if hasattr(l.data_pagamento, 'date') else l.data_pagamento
                if data_pag >= inicio_mes and data_pag <= hoje:
                    valor = Decimal(str(l.valor))
                    if l.tipo == TipoLancamento.RECEITA:
                        receitas_mes += valor
                    else:
                        despesas_mes += valor
            
            if l.status == StatusLancamento.PENDENTE:
                valor = Decimal(str(l.valor))
                if l.tipo == TipoLancamento.RECEITA:
                    total_receber += valor
                    if l.data_vencimento < hoje:
                        vencidos_receber += valor
                else:
                    total_pagar += valor
                    if l.data_vencimento < hoje:
                        vencidos_pagar += valor
        
        # Saldo em caixa
        saldo_caixa = sum(Decimal(str(c.saldo_inicial)) for c in contas)
        
        # Liquidez = (Saldo + A Receber) / A Pagar
        liquidez = float((saldo_caixa + total_receber) / total_pagar) if total_pagar > 0 else 0
        
        # Margem líquida = (Receitas - Despesas) / Receitas * 100
        margem = float((receitas_mes - despesas_mes) / receitas_mes * 100) if receitas_mes > 0 else 0
        
        return jsonify({
            'saldo_caixa': float(saldo_caixa),
            'mes_atual': {
                'receitas': float(receitas_mes),
                'despesas': float(despesas_mes),
                'saldo': float(receitas_mes - despesas_mes)
            },
            'pendentes': {
                'receber': float(total_receber),
                'pagar': float(total_pagar)
            },
            'vencidos': {
                'receber': float(vencidos_receber),
                'pagar': float(vencidos_pagar)
            },
            'indicadores': {
                'liquidez': round(liquidez, 2),
                'margem_liquida': round(margem, 2)
            }
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/relatorios/inadimplencia', methods=['GET'])
def relatorio_inadimplencia():
    """Relatório de inadimplência"""
    try:
        lancamentos = db.listar_lancamentos()
        hoje = date.today()
        
        inadimplentes = []
        
        for l in lancamentos:
            if l.status == StatusLancamento.PENDENTE and l.data_vencimento < hoje:
                dias_atraso = (hoje - l.data_vencimento).days
                inadimplentes.append({
                    'id': l.id,
                    'tipo': l.tipo.value,
                    'descricao': l.descricao,
                    'valor': float(l.valor),
                    'data_vencimento': l.data_vencimento.isoformat(),
                    'dias_atraso': dias_atraso,
                    'pessoa': l.pessoa or 'Não informado',
                    'categoria': l.categoria or 'Sem categoria'
                })
        
        # Ordenar por dias de atraso (maior para menor)
        inadimplentes.sort(key=lambda x: x['dias_atraso'], reverse=True)
        
        total_inadimplente = sum(i['valor'] for i in inadimplentes)
        
        return jsonify({
            'inadimplentes': inadimplentes,
            'total': total_inadimplente,
            'quantidade': len(inadimplentes)
        })
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/favicon.ico')
def favicon():
    """Retorna o favicon"""
    return send_from_directory(
        os.path.join(app.root_path, 'static'),
        'favicon.svg',
        mimetype='image/svg+xml'
    )


if __name__ == '__main__':
    print("="*60)
    print("Sistema Financeiro - Versão Web")
    print("="*60)
    print("Servidor iniciado em: http://localhost:5000")
    print("="*60)
    app.run(debug=True, host='0.0.0.0', port=5000, use_reloader=False)
